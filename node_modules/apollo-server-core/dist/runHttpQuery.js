"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const sha256 = require('hash.js/lib/hash/sha/256');
const lodash_1 = require("lodash");
const runQuery_1 = require("./runQuery");
const graphqlOptions_1 = require("./graphqlOptions");
const apollo_server_errors_1 = require("apollo-server-errors");
const caching_1 = require("./caching");
function prettyJSONStringify(value) {
    return JSON.stringify(value) + '\n';
}
class HttpQueryError extends Error {
    constructor(statusCode, message, isGraphQLError = false, headers) {
        super(message);
        this.name = 'HttpQueryError';
        this.statusCode = statusCode;
        this.isGraphQLError = isGraphQLError;
        this.headers = headers;
    }
}
exports.HttpQueryError = HttpQueryError;
function throwHttpGraphQLError(statusCode, errors, optionsObject) {
    throw new HttpQueryError(statusCode, prettyJSONStringify({
        errors: optionsObject
            ? apollo_server_errors_1.formatApolloErrors(errors, {
                debug: optionsObject.debug,
                formatter: optionsObject.formatError,
            })
            : errors,
    }), true, {
        'Content-Type': 'application/json',
    });
}
function runHttpQuery(handlerArguments, request) {
    return __awaiter(this, void 0, void 0, function* () {
        let isGetRequest = false;
        let optionsObject;
        const debugDefault = process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test';
        let cacheControl;
        try {
            optionsObject = yield graphqlOptions_1.resolveGraphqlOptions(request.options, ...handlerArguments);
        }
        catch (e) {
            e.message = `Invalid options provided to ApolloServer: ${e.message}`;
            if (!debugDefault) {
                e.warning = `To remove the stacktrace, set the NODE_ENV environment variable to production if the options creation can fail`;
            }
            return throwHttpGraphQLError(500, [e], { debug: debugDefault });
        }
        if (optionsObject.debug === undefined) {
            optionsObject.debug = debugDefault;
        }
        let requestPayload;
        switch (request.method) {
            case 'POST':
                if (!request.query || Object.keys(request.query).length === 0) {
                    throw new HttpQueryError(500, 'POST body missing. Did you forget use body-parser middleware?');
                }
                requestPayload = request.query;
                break;
            case 'GET':
                if (!request.query || Object.keys(request.query).length === 0) {
                    throw new HttpQueryError(400, 'GET query missing.');
                }
                isGetRequest = true;
                requestPayload = request.query;
                break;
            default:
                throw new HttpQueryError(405, 'Apollo Server supports only GET/POST requests.', false, {
                    Allow: 'GET, POST',
                });
        }
        let isBatch = true;
        if (!Array.isArray(requestPayload)) {
            isBatch = false;
            requestPayload = [requestPayload];
        }
        const requests = requestPayload.map((requestParams) => __awaiter(this, void 0, void 0, function* () {
            try {
                let queryString = requestParams.query;
                let extensions = requestParams.extensions;
                let persistedQueryHit = false;
                let persistedQueryRegister = false;
                if (isGetRequest && extensions) {
                    try {
                        extensions = JSON.parse(extensions);
                    }
                    catch (error) {
                        throw new HttpQueryError(400, 'Extensions are invalid JSON.');
                    }
                }
                if (extensions && extensions.persistedQuery) {
                    if (!optionsObject.persistedQueries ||
                        !optionsObject.persistedQueries.cache) {
                        if (isBatch) {
                            throw new apollo_server_errors_1.PersistedQueryNotSupportedError();
                        }
                        return throwHttpGraphQLError(200, [new apollo_server_errors_1.PersistedQueryNotSupportedError()], optionsObject);
                    }
                    else if (extensions.persistedQuery.version !== 1) {
                        throw new HttpQueryError(400, 'Unsupported persisted query version');
                    }
                    const sha = extensions.persistedQuery.sha256Hash;
                    if (queryString === undefined) {
                        queryString =
                            (yield optionsObject.persistedQueries.cache.get(`apq:${sha}`)) ||
                                undefined;
                        if (queryString) {
                            persistedQueryHit = true;
                        }
                        else {
                            if (isBatch) {
                                throw new apollo_server_errors_1.PersistedQueryNotFoundError();
                            }
                            return throwHttpGraphQLError(200, [new apollo_server_errors_1.PersistedQueryNotFoundError()], optionsObject);
                        }
                    }
                    else {
                        const calculatedSha = sha256()
                            .update(queryString)
                            .digest('hex');
                        if (sha !== calculatedSha) {
                            throw new HttpQueryError(400, 'provided sha does not match query');
                        }
                        persistedQueryRegister = true;
                        (() => __awaiter(this, void 0, void 0, function* () {
                            return (optionsObject.persistedQueries &&
                                optionsObject.persistedQueries.cache.set(`apq:${sha}`, queryString));
                        }))().catch(error => {
                            console.warn(error);
                        });
                    }
                }
                if (!queryString) {
                    throw new HttpQueryError(400, 'Must provide query string.');
                }
                if (typeof queryString !== 'string') {
                    if (queryString && queryString.kind === 'Document') {
                        throw new HttpQueryError(400, "GraphQL queries must be strings. It looks like you're sending the " +
                            'internal graphql-js representation of a parsed query in your ' +
                            'request instead of a request in the GraphQL query language. You ' +
                            'can convert an AST to a string using the `print` function from ' +
                            '`graphql`, or use a client like `apollo-client` which converts ' +
                            'the internal representation to a string for you.');
                    }
                    throw new HttpQueryError(400, 'GraphQL queries must be strings.');
                }
                let nonQueryError;
                if (isGetRequest) {
                    nonQueryError = new HttpQueryError(405, `GET supports only query operation`, false, {
                        Allow: 'POST',
                    });
                }
                const operationName = requestParams.operationName;
                let variables = requestParams.variables;
                if (typeof variables === 'string') {
                    try {
                        variables = JSON.parse(variables);
                    }
                    catch (error) {
                        throw new HttpQueryError(400, 'Variables are invalid JSON.');
                    }
                }
                let context = optionsObject.context;
                if (!context) {
                    context = {};
                }
                else if (typeof context === 'function') {
                    try {
                        context = yield context();
                    }
                    catch (e) {
                        e.message = `Context creation failed: ${e.message}`;
                        if (e.extensions &&
                            e.extensions.code &&
                            e.extensions.code !== 'INTERNAL_SERVER_ERROR') {
                            return throwHttpGraphQLError(400, [e], optionsObject);
                        }
                        else {
                            return throwHttpGraphQLError(500, [e], optionsObject);
                        }
                    }
                }
                else {
                    context = Object.assign(Object.create(Object.getPrototypeOf(context)), context);
                }
                if (optionsObject.dataSources) {
                    const dataSources = optionsObject.dataSources() || {};
                    for (const dataSource of Object.values(dataSources)) {
                        if (dataSource.initialize) {
                            dataSource.initialize({ context, cache: optionsObject.cache });
                        }
                    }
                    if ('dataSources' in context) {
                        throw new Error('Please use the dataSources config option instead of putting dataSources on the context yourself.');
                    }
                    context.dataSources = dataSources;
                }
                if (optionsObject.cacheControl !== false) {
                    if (typeof optionsObject.cacheControl === 'boolean' &&
                        optionsObject.cacheControl === true) {
                        cacheControl = {
                            stripFormattedExtensions: false,
                            calculateHttpHeaders: false,
                            defaultMaxAge: 0,
                        };
                    }
                    else {
                        cacheControl = Object.assign({ stripFormattedExtensions: true, calculateHttpHeaders: true, defaultMaxAge: 0 }, optionsObject.cacheControl);
                    }
                }
                let params = {
                    schema: optionsObject.schema,
                    queryString,
                    nonQueryError,
                    variables: variables,
                    context,
                    rootValue: optionsObject.rootValue,
                    operationName: operationName,
                    validationRules: optionsObject.validationRules,
                    formatError: optionsObject.formatError,
                    formatResponse: optionsObject.formatResponse,
                    fieldResolver: optionsObject.fieldResolver,
                    debug: optionsObject.debug,
                    tracing: optionsObject.tracing,
                    cacheControl: cacheControl
                        ? lodash_1.omit(cacheControl, [
                            'calculateHttpHeaders',
                            'stripFormattedExtensions',
                        ])
                        : false,
                    request: request.request,
                    extensions: optionsObject.extensions,
                    persistedQueryHit,
                    persistedQueryRegister,
                };
                return runQuery_1.runQuery(params);
            }
            catch (e) {
                if (e.name === 'HttpQueryError') {
                    throw e;
                }
                return {
                    errors: apollo_server_errors_1.formatApolloErrors([e], optionsObject),
                };
            }
        }));
        let responses;
        try {
            responses = yield Promise.all(requests);
        }
        catch (e) {
            if (e.name === 'HttpQueryError') {
                throw e;
            }
            return throwHttpGraphQLError(500, [e], optionsObject);
        }
        const responseInit = {
            headers: {
                'Content-Type': 'application/json',
            },
        };
        if (cacheControl) {
            if (cacheControl.calculateHttpHeaders) {
                const calculatedHeaders = caching_1.calculateCacheControlHeaders(responses);
                responseInit.headers = Object.assign({}, responseInit.headers, calculatedHeaders);
            }
            if (cacheControl.stripFormattedExtensions) {
                responses.forEach(response => {
                    if (response.extensions) {
                        delete response.extensions.cacheControl;
                        if (Object.keys(response.extensions).length === 0) {
                            delete response.extensions;
                        }
                    }
                });
            }
        }
        if (!isBatch) {
            const graphqlResponse = responses[0];
            if (graphqlResponse.errors && typeof graphqlResponse.data === 'undefined') {
                return throwHttpGraphQLError(400, graphqlResponse.errors);
            }
            const stringified = prettyJSONStringify(graphqlResponse);
            responseInit.headers['Content-Length'] = Buffer.byteLength(stringified, 'utf8').toString();
            return {
                graphqlResponse: stringified,
                responseInit,
            };
        }
        const stringified = prettyJSONStringify(responses);
        responseInit.headers['Content-Length'] = Buffer.byteLength(stringified, 'utf8').toString();
        return {
            graphqlResponse: stringified,
            responseInit,
        };
    });
}
exports.runHttpQuery = runHttpQuery;
//# sourceMappingURL=runHttpQuery.js.map